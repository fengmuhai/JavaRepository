多线程面试题
==================

1.什么是线程？
------------------
自己的理解：进程是操作系统运行应用程序的一个内存空间、CUP资源。而线程是用于进程计算分配的更小的内存和CUP资源，使用多线程可以充分利用CPU资源。

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。
比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒


2.什么是线程安全和线程不安全？
------------------
简单说就是，加锁是线程安全的，不加锁是线程不安全的。在多线程环境下，当多个线程对资源进行读写时，如果没有对资源加锁，那么读取到的数据有可能被多个线程先后修改，变成了脏数据。


3.现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？
-------------------
有两种实现方式，第一种用Thread类的join方法；另一种用CountDownLatch实现。

**Thread类的join方法**
```
public class JoinTest {

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread1 = new MyThread("myThread1");
        MyThread myThread2 = new MyThread("myThread2");
        MyThread myThread3 = new MyThread("myThread3");

        myThread1.start();
        myThread1.join();

        myThread2.start();
        myThread2.join();

        myThread3.start();
    }

}
class MyThread extends Thread {

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        System.out.println(this.getName() + " work done.");
    }
}
```

**CountDownLatch实现**
```
    public static void main(String[] args) throws InterruptedException {

        CountDownLatch count = new CountDownLatch(1);

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread1 work done.");
                count.countDown();
            }
        }, "Thread1").start();

        count.await();

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread2 work done.");
                count.countDown();
            }
        }, "Thread2").start();

        count.await();

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread3 work done.");
                count.countDown();
            }
        }, "Thread3").start();
    }
```

4.ReentrantLock（可重入锁）与synchronized有什么区别？
----------------
**1）可重入性**：ReenTrantLock的字面意思就是再进入的锁，其实synchronized关键字所使用的锁也是可重入的，两者区别不大。都是同一个线程每进入一次，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。

**2）锁的实现**：Synchronized是依赖于JVM实现的，而ReenTrantLock是JDK实现的。

性能的区别：

**3）性能的区别**：在Synchronized优化以前，synchronized的性能是比ReenTrantLock差很多的，但是自从Synchronized引入了偏向锁，轻量级锁（自旋锁）后，两者的性能就差不多了，在两种方法都可用的情况下，官方甚至建议使用synchronized，其实synchronized的优化我感觉就借鉴了ReenTrantLock中的CAS技术。都是试图在用户态就把加锁问题解决，避免进入内核态的线程阻塞。

**4）功能区别**：

便利性：很明显Synchronized的使用比较方便简洁，并且由编译器去保证锁的加锁和释放，而ReenTrantLock需要手工声明来加锁和释放锁，为了避免忘记手工释放锁造成死锁，所以最好在finally中声明释放锁。

锁的细粒度和灵活度：很明显ReenTrantLock优于Synchronized

**5）ReenTrantLock独有的能力**：

1.ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。

2.ReenTrantLock提供了一个Condition（条件）类，用来实现分组唤醒需要唤醒的线程们，而不是像synchronized要么随机唤醒一个线程要么唤醒全部线程。

3.ReenTrantLock提供了一种能够中断等待锁的线程的机制，通过lock.lockInterruptibly()来实现这个机制。


5.什么是乐观锁和悲观锁？
-------------------
**悲观锁**

Java在JDK1.5之前都是靠synchronized关键字保证同步的，这种通过使用一致的锁定协议来协调对共享状态的访问，可以确保无论哪个线程持有共享变量的锁，都采用独占的方式来访问这些变量。独占锁其实就是一种悲观锁，所以可以说synchronized是悲观锁。


**乐观锁**
乐观锁（ Optimistic Locking）其实是一种思想。相对悲观锁而言，乐观锁假设认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。

面试的时候可以拿synchronized和CAS技术来分别说明乐观锁和悲观锁。


6.Java 中 wait 和 sleep 方法有什么区别？
----------------------
两者主要的区别就是等待释放锁和监视器。sleep方法在等待时不会释放任何锁或监视器，wait会释放锁。wait 方法多用于线程间通信，而 sleep 只是在执行时暂停。


7.如何在 Java 中实现一个阻塞队列
----------------------
```
public class BlockQueueV2<T> {

    private LinkedList<T> list;
    private int maxSize;

    public BlockQueueV2() {
        this.maxSize = 8;
        this.list = new LinkedList<T>();
    }

    public BlockQueueV2(int maxSize) {
        this.maxSize = maxSize;
        this.list = new LinkedList<T>();
    }

    public synchronized void enqueue(T t) throws InterruptedException {
        while (list.size() == maxSize) {
            wait();
        }
        if(0 == list.size()) {
            notifyAll();
        }
        list.add(t);

    }

    public synchronized T dequeue() throws InterruptedException {
        while (0 == list.size()) {
            wait();
        }
        if(list.size() == maxSize) {
            notifyAll();
        }
        return list.remove();
    }

    public synchronized int getSize() {
        return list.size();
    }

}
```

8.如何在 Java 中编写代码解决生产者消费者问题？
----------------------
如果能实现阻塞队列的代码，那么很容易实现生产者，消费者问题的代码。可以说，他们就是同一个东西，阻塞队列的入列相当于生产者，出列相当于消费者。

所以，发现了一个问题，阻塞队列就是为消费者生产者这类问题而设计的，使用阻塞队列也很容易实现消费者-生产者的代码。

**1）使用wait()/notifyAll()实现**

**生产者**
```
/**
 * 生产者
 *
 * @author MouHi
 * @create 2019/2/22 下午1:45
 */
public class Producer implements Runnable {

    private final Vector sharedProducts;
    private long maxNum;
    private long totalNum;

    private Producer() {
        this.sharedProducts = new Vector();
        this.maxNum = 10;
    }

    public Producer(Vector sharedProducts, long maxNum, long totalNum) {
        this.sharedProducts = sharedProducts;
        this.maxNum = maxNum;
        this.totalNum = totalNum;
    }

    @Override
    public void run() {
        for(int i=0;i<totalNum;i++) {
            working(i);
            try {
                Thread.sleep(1000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public void working(int source) {

        try {
            //如果生产产品数量达到上限需要等待
            while(sharedProducts.size() == this.maxNum) {
                synchronized (sharedProducts) {
                    System.out.println("生产池数量达到上限："+this.maxNum + "；线程："+Thread.currentThread().getName()+"等待中");
                    sharedProducts.wait();

                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        synchronized (sharedProducts) {
            int product = source + 1;
            System.out.println("生产产品:" + product);
            sharedProducts.add(product);
            sharedProducts.notifyAll();
            /**
             * 1.notifyAll和notify的区别是，notifyAll回唤醒全部等待锁的线程，而notify只会随机唤醒一个等待的线程；
             * 2.notify可能会导致死锁，而notifyAll不会。分析：一个生产者P1，两个消费者C1，C2。C1消费完P1生产的产品后为空，
             *   唤醒了C2，那么由于C2判断到P1为空，一直等待P1生产产品 并一直持有锁，没有达到释放锁的条件，造成死锁现象。
             * 3.所以不建议使用notify，而使用notifyAll。推荐设置等待超时时间，wait(timeout);
             */
        }

    }
}
```
**消费者**
```
/**
 * 消费者
 *
 * @author MouHi
 * @create 2019/2/22 下午2:17
 */
public class Consumer implements Runnable {

    private final Vector sharedProducts;

    public Consumer() {
        sharedProducts = new Vector();
    }

    public Consumer(Vector sharedProducts) {
        this.sharedProducts = sharedProducts;
    }

    @Override
    public void run() {
        while (true) {
            System.out.println("消费产品："+consume());
            try {
                Thread.sleep(5000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }

    public int consume() {
        try {
            //如果产品空，则等待
            while(sharedProducts.isEmpty()) {
                synchronized (sharedProducts) {
                    System.out.println("sharedProducts is null, "+Thread.currentThread().getName()+" is waitting.");
                    sharedProducts.wait(10000);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        synchronized (sharedProducts) {
            sharedProducts.notifyAll();
            return (int) sharedProducts.remove(0);
        }
    }
}
```
**测试方法**
```
public class Tester {

    public static void main(String[] args) {
        Vector sharedProducts = new Vector();
        int totalNum = 20;
        int maxNum = 5;

        new Thread(new Consumer(sharedProducts), "消费者线程-1").start();
        new Thread(new Producer(sharedProducts, maxNum, totalNum), "生产者线程-1").start();
    }
}
```

**2)使用阻塞队列实现**

**生产者**
```
/**
 * 使用blockingQueue实现最简单的生产者-消费者
 *
 * @author MouHi
 * @create 2019/2/26 上午8:14
 */
public class Producer implements Runnable {

    private final BlockingQueue queue;

    public Producer(BlockingQueue queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        for(int i=0;i<20;i++) {
            try {
                System.out.println("Produce:"+i + "，当前队列大小："+queue.size());
                queue.put(i+"");
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }
}

```
**消费者**
```
/**
 * 消费者
 *
 * @author MouHi
 * @create 2019/2/26 上午9:45
 */
public class Consumer implements Runnable {

    private final BlockingQueue queue;

    public Consumer(BlockingQueue queue) {
        this.queue = queue;
    }

    @Override
    public void run() {
        while (true) {

            try {
                if(null == queue || queue.isEmpty()) {
                    System.out.println("consumer: producer no data!");
                } else {
                    String data = (String) queue.take();
                    System.out.println("consumer:"+data);
                }
                Thread.sleep(2000);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }
    }


}
```
**测试代码**
```
public class Tester {

    public static void main(String[] args) {
        BlockingQueue queue = new LinkedBlockingQueue(5);

        Producer producer = new Producer(queue);
        Consumer consumer1 = new Consumer(queue);
        Consumer consumer2 = new Consumer(queue);

        new Thread(producer).start();
        new Thread(consumer1).start();
        new Thread(consumer2).start();


    }
}
```


9.写一段死锁代码。你在 Java 中如何解决死锁？
--------------------
