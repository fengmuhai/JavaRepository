多线程面试题
==================

1.什么是线程？
------------------
自己的理解：进程是操作系统运行应用程序的一个内存空间、CUP资源。而线程是用于进程计算分配的更小的内存和CUP资源，使用多线程可以充分利用CPU资源。

线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中，是进程中的实际运作单位，可以使用多线程对进行运算提速。
比如，如果一个线程完成一个任务要100毫秒，那么用十个线程完成改任务只需10毫秒


2.什么是线程安全和线程不安全？
------------------
简单说就是，加锁是线程安全的，不加锁是线程不安全的。在多线程环境下，当多个线程对资源进行读写时，如果没有对资源加锁，那么读取到的数据有可能被多个线程先后修改，变成了脏数据。


3.现在有线程 T1、T2 和 T3。你如何确保 T2 线程在 T1 之后执行，并且 T3 线程在 T2 之后执行？
-------------------
有两种实现方式，第一种用Thread类的join方法；另一种用CountDownLatch实现。

**Thread类的join方法**
```
public class JoinTest {

    public static void main(String[] args) throws InterruptedException {
        MyThread myThread1 = new MyThread("myThread1");
        MyThread myThread2 = new MyThread("myThread2");
        MyThread myThread3 = new MyThread("myThread3");

        myThread1.start();
        myThread1.join();

        myThread2.start();
        myThread2.join();

        myThread3.start();
    }

}
class MyThread extends Thread {

    public MyThread(String name) {
        super(name);
    }

    @Override
    public void run() {
        System.out.println(this.getName() + " work done.");
    }
}
```

**CountDownLatch实现**
```
    public static void main(String[] args) throws InterruptedException {

        CountDownLatch count = new CountDownLatch(1);

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread1 work done.");
                count.countDown();
            }
        }, "Thread1").start();

        count.await();

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread2 work done.");
                count.countDown();
            }
        }, "Thread2").start();

        count.await();

        new Thread(new Runnable() {
            @Override
            public void run() {
                System.out.println("Thread3 work done.");
                count.countDown();
            }
        }, "Thread3").start();
    }
```

