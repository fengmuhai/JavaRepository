TCP/IP协议
==================
参考：https://blog.csdn.net/qzcsu/article/details/72861891

https://blog.csdn.net/qq_38950316/article/details/81087809

https://www.cnblogs.com/zmlctt/p/3690998.html

1.TCP协议
------------------
TCP协议，全程Transport Control Protocol，传输控制协议。TCP是一种面向连接、可靠、全双工的、面向字节流的传输协议。在计算机OSI网络模型中，它完成第四层的传输层所指定的功能。用户数据报协议UDP，是同一层内另一个重要的传输协议



2.TCP/IP的四层协议系统
------------------

1）链路层：有时也称作数据链路层和网络接口层，通常包括操作系统中的设备驱动程序和计算机中对应的网络接口卡。

2）网络层：有时也称作互联网层，处理分组在网络中的活动。网络层包括IP协议（网络协议）、ICMP协议（互联网控制报文协议）、IGMP（Internet组管理协议）。

3）运输层：包含TCP（传输控制协议）和UDP（用户数据报协议）。TCP把数据分成小块，交给网络层，UDP则为应用层服务，把数据报的分组从一台主机发送到另一台主机，但并不能保证送到。

4）应用层：负责处理特定应用程序的细节，包括Tenet远程登录、FTP文件传输协议、SMTP简单邮件传送协议、SNMP简单网络管理协议。




3.TCP的三次握手 建立连接
-----------------------
所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。

**1）三次握手示意图**
![image](https://github.com/fengmuhai/JavaRepository/blob/master/tcp-ip/images/tcp%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.png)

**1.连接开始时，连接建立方Client发送了SYN包，并加上了序列号seq=a;  **
**2.服务器接收到SYN信息，发送SYN+ACK包，并加上了包序列号seq=b，确认号ack=a+1;  **
**3.客户端接收到SYN+ACK信息，发送ACK包，并加上包序列号seq=a+1，确认号ack=b+1;  **

1. 连接开始时，连接建立方(Client)发送SYN包，并包含了自己的初始序号a；

2. 连接接受方(Server)收到SYN包以后会回复一个SYN包，其中包含了对上一个a包的回应信息ACK，回应的序号为下一个希望收到包的序号，即a＋1，然后还包含了自己的初始序号b；

3. 连接建立方(Client)收到回应的SYN包以后，回复一个ACK包做响应，其中包含了下一个希望收到包的序号即b＋1。



**2）三次握手做了什么**：  
a）连接服务器指定端口，建立TCP连接；  
b）同步连接双发的序列号和确认号，并交换TCP窗口大小信息，以便后续通信的有序进行；  



**3）为什么是三次握手，而不是两次，四次？**  
我们知道**TCP是全双工的**。先说一下**全双工、单工、半双工**的概念。**半双工**是指A可以给B发消息，B也可以给A发消息，但不能同时发，即：A给B发消息的时候，B不能给A发消息；**单双工**是指A只能发给B，B不能发给A，或者反之；全双工是指A能发给B，而同一时间B也能发给A。

现在A和B通信，每次握手当作一次通信：  
第一次握手：A和B打电话说，你可以听到我说话么？  
第二次握手：B收到A的信息，回复A说，我可以听到你说话，你可以听到我说话么？  
第三次握手：A收到B信息，说：我可以听到，我要给你发信息了。  

**三次握手之后，A和B能确定的是，双发都能听到对方说话了，可以开始正常通信。**

**如果两次握手**，那么B回复A后，B不确定A是否能收到信息，如果B先说话，那么A可能后面的消息都接收不到，会出现问题；（**注意**：HTTP是基于TCP协议的，所以每次都是客户端发送请求，服务器应答，但是TCP还可以给其他应用层提供服务，即可能A、B在建立链接之后，谁都可能先开始通信。）

**如果是四次握手**，那么就造成了资源浪费，因为3次握手已经可以保证A和B进行正常通信。



**4）SYN攻击（扩展）**
在三次握手过程中，服务器发送SYN-ACK之后，收到客户端的ACK之前的TCP连接称为半连接(half-open connect).此时服务器处于Syn_RECV状态.当收到ACK后，服务器转入ESTABLISHED状态.
Syn攻击就是 攻击客户端 在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直 至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。
Syn攻击是一个典型的DDOS攻击。检测SYN攻击非常的方便，当你在服务器上看到大量的半连接状态时，特别是源IP地址是随机的，基本上可以断定这是一次SYN攻击.在Linux下可以如下命令检测是否被Syn攻击
netstat -n -p TCP | grep SYN_RECV
一般较新的TCP/IP协议栈都对这一过程进行修正来防范Syn攻击，修改tcp协议实现。主要方法有SynAttackProtect保护机制、SYN cookies技术、增加最大半连接和缩短超时时间等.
但是不能完全防范syn攻击。



**5）TCP连接状态图（进阶）**
![image](https://github.com/fengmuhai/JavaRepository/blob/master/tcp-ip/images/TCP%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E5%9B%BE.png)

1.TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；

2.TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位SYN=1，同时选择一个初始序列号 seq=x ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。**TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号**。

3.TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 ACK=1，SYN=1，确认号是ack=x+1，同时也要为自己初始化一个序列号 seq=y，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。**这个报文也不能携带数据，但是同样要消耗一个序号**。

4.TCP客户进程收到确认后，还要向服务器给出确认。确认报文的ACK=1，ack=y+1，自己的序列号seq=x+1，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。**TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号**。

5.当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。 




4.TCP的四次挥手 断开连接
-----------------------
TCP的连接的拆除需要发送四个包，因此称为四次挥手(four-way handshake)。客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close()操作即可产生挥手操作。


**1）四次挥手示意图**
![image](https://github.com/fengmuhai/JavaRepository/blob/master/tcp-ip/images/tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B.png)

1. 首先进行关闭的一方（即发送第一个FIN）将执行主动关闭，而另一方（收到这
个FIN）执行被动关闭。

2. 当服务器收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一
样，一个FIN将占用一个序号。

3. 同时TCP服务器还向应用程序（即丢弃服务器）传送一个文件结束符。接着这个服务器程序就关闭它的连接，导致它的TCP端发送一个FIN。

4. 客户必须发回一个确认，并将确认序号设置为收到序号加1。



**2)TCP断开连接状态图**
![image](https://github.com/fengmuhai/JavaRepository/blob/master/tcp-ip/images/TCP%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5%E7%8A%B6%E6%80%81%E5%9B%BE.png)

1.客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 **TCP规定，FIN报文段即使不携带数据，也要消耗一个序号**。

2.服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。**TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间**。

3.客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（**在这之前还需要接受服务器发送的最后的数据**）。

4.服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。

5.客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。**注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态**。

6.服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。**可以看到，服务器结束TCP连接的时间要比客户端早一些**。




**3)为什么建立连接是三次握手，关闭连接确是四次挥手呢？**

**建立连接的时候**， 服务器在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。   
**而关闭连接时**，服务器收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送，从而导致多了一次。




**4)为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？**

答：虽然按道理，四个报文都发送完毕，我们可以直接进入CLOSE状态了，但是我们必须假象网络是不可靠的，有可能最后一个ACK丢失。**所以TIME_WAIT状态就是用来重发可能丢失的ACK报文**。在Client发送出最后的ACK回复，但该ACK可能丢失。**Server如果没有收到ACK，将不断重复发送FIN片段**。所以Client不能立即关闭，它必须确认Server接收到了该ACK。Client会在发送出ACK之后进入到TIME_WAIT状态。Client会设置一个计时器，等待2MSL的时间。如果在该时间内再次收到FIN，那么Client会重发ACK并再次等待2MSL。所谓的2MSL是两倍的MSL(Maximum Segment Lifetime)。MSL指一个片段在网络中最大的存活时间，2MSL就是一个发送和一个回复所需的最大时间。如果直到2MSL，Client都没有再次收到FIN，那么Client推断ACK已经被成功接收，则结束TCP连接。




**5)如果已经建立了连接，但是客户端突然出现故障了怎么办？**

TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 

