2-3树与2-3-4树
=====================

2-3树
---------------------

#### 2-3树是一棵自平衡的多路查找树，它并不是一棵二叉树，具有如下性质：

（1）每个节点有1个或2个key，对应的子节点为2个子节点或3个子节点；

（2）所有叶子节点到根节点的长度一致；

（3）每个节点的key从左到右保持了从小到大的顺序，两个key之间的子树中所有的key一定大于它的父节点的左key，小于父节点的右key。

如图所示：

![](https://github.com/fengmuhai/JavaRepository/blob/master/images/2-3-tree.png)

#### 为什么会有2-3树这种数据结构呢？是因为他的查询复杂度比平衡二叉树还高吗？

其实不是的，实际上2-3树的查询时间复杂度也是为 O(logN) ，而出现这种多路查找树，主要是跟内存与磁盘交互有关。

我们知道在内存IO的速度比磁盘IO要快的多的多，但是同样空间大小的内存比硬盘要贵的多的多，像TB级别的数据库不可能全部读出来放到内存中去，太过昂贵，而且也没必要，大部分数据是不经常用的，所以就需要内存与外存互相结合。

而如果用平衡二叉树这种数据结构，在大数据量的情况下，树肯定会很高，此时查个数据对磁盘读个几千上万次那肯定是不行的（有人可能说把数据的索引文件全部放到内存中，然后把源数据放在硬盘中，这样在内存中定位到源数据Id，然后去外存中取源数据，这样肯定是不行的，不要以为索引文件很小，像搜索引擎的倒排索引文件比源文件还要大），所以用多路查找树这种数据结构，高阶的情况下，树不用很高就可以标识很大的数据量了，检索次数就大大减少了，用这种数据结构去磁盘中存取数据，磁盘IO次数的次数也会很少。

### 2-3树的插入操作

**首先一定是在叶子节点插入；另外如果2-3树中已存在当前插入的key，则插入失败

下面就在这两点的前提下，进行2-3树插入流程的分析：

（1）如果待插入的节点只有1个key，则直接插入即可；

（2）如果待插入的节点有2个key，则对节点进行分裂，即2个key加上待插入的key，这3个key分裂成1个key跟两个子节点，然后将分裂之后的3个key中的父节点看作向上层插入的key，然后重复（1）、（2）步骤，直到满足2-3树的定义性质。

**1.如下图所示，插入“7”，而此时节点“5”只有一个key，则直接插入即可，形成节点“5 7”。

![](https://github.com/fengmuhai/JavaRepository/blob/master/images/2-3-tree-insert-1.png)

**2.此时如果再插入“6”，而节点“5 7”已经有2个key了，所以需要先进行分裂。

![](https://github.com/fengmuhai/JavaRepository/blob/master/images/2-3-tree-insert-2.png)

**3.“5 7”节点与新插入的“6”分裂之后，如下图所示，

![](https://github.com/fengmuhai/JavaRepository/blob/master/images/2-3-tree-insert-3.png)

**4.此时需要将“6”向父节点插入，而父节点“13 30”又包含2个key，则需要再次分裂，即如下图所示，“13 30”与“6”分裂成父节点为“13”，子节点为“6”跟“30”

![](https://github.com/fengmuhai/JavaRepository/blob/master/images/2-3-tree-insert-4.png)

**5.再将节点“13”看作向父节点插入，而此时父节点“50”只有一个key，则将“13”与“50”直接合并即可，如下图所示，完成节点的插入调整，如下图所示

![](https://github.com/fengmuhai/JavaRepository/blob/master/images/2-3-tree-insert-5.png)



